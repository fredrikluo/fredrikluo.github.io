---
title: 一个3天的项目是如何变成2个星期＋1万行代码修改量的
author: fredrik.luo
layout: post
permalink: /?p=97
categories:
  - Uncategorized
---
我相信所有的软件开发管理者，项目/产品经理，甚至一些软件开发工程师都会有这样的感觉，一个项目估计3天，甚至工程师自己都觉得，3天无论如何都搞定了啊，结果做起来往往就不是这样子了， 甚至一些非常好的工程师，项目经常是一拖又拖，老板觉得下面的人都在偷懒，不严肃，耽误业务流程，下面的人觉得已经快要累死了，每天做梦都在写代码，还是搞不定。

为什么？

说大道理之前给，不妨先给大家看个例子：

这个是我大概一个月前写的一个东西，虽然我不专职写代码已经很久，但是每个季度我还是会给自己安排一些任务，以保持我的工程敏感度( Engineering sense).

任务是写一个用来计算一个APP的代码文件( dex 文件)中每个方法大小的小工具， 这样可以精确的控制包体大小，还可以做回归测试等等。我看看了需求，觉得这个东西拿 python 应该可以很快搞定， 另外安卓开发工具里面自带了dex文件分析器， 只需要分析一下它的输出就好。

第一天：快速写了一个脚本分析 dexdump 的输出，可以算出每个方法的自己的代码大小，感觉好开心，觉得我就是我，是不一样的烟火，还估了3天，一天就搞定了。

第二天: 准备打包发布，突然发现，呃，为何大小差了怎么多。为何原来的 APP 就 2M 大小，我算出来所有的方法加起来得有 5M 多？ 这个是个啥意思。仔细看了看反编译的输出，突然发现一个问题，Dex 文件里面有非常多的共享对象， 比如一个字符串“我爱你”， 结果4个类都用到了，这几个字节我不可能算4次吧， 那么问题来了，dexdump 输出里面是没有这些信息的，我要得到这些信息需要自己解析 Dex. 好吧， 我还有时间，我来搞一个Dex解析器。

第三天：Dex 文件解析起来倒是不复杂，不过是个体力活，几十个结构，各种引用，于是想，不要重新发明轮子了，我去找个开源的库。 找了一圈，找到了一个叫 dexerity 的 python 和 C++ 的混合库，看看了人气还不错，项目也蛮活跃的，不像是一个坑爹货，于是重新写了脚本，使用 dexerity 解析。突然发现 dexerity 里面所有大小的计算都是基于解析后的大小，而不是解析前大小，而我的嗜好比较特殊，我需要解析前的大小，于是花了几个小时改造了一下，加入解析前大小的采集。

第四天：写好脚本其他部分，分析所有对象的依赖性，构建出一个依赖树。 我终于可以把共享对象的大小公摊到其他对象身上了，哇哈哈哈。

第五天：呃，为何数字还是不对，虽然就多了2个字节，为何还是不对呢？ 对我这种类处女座患者，别说2个字节，半个字节都不行。于是查，一个一个结构查，终于发现是 dexerity 库里里面有一个 bug. 作者忽略了编译器喜欢把结构体 4 字节对齐这种特殊嗜好， 有一个6个字节的结构体，被当成8个字节，于是算多了2个字节。尼玛，还以为你们是高手呢。 改掉了bug,给原作者发了一个补丁，准备收工， 虽然多了2天，还好。

第六天：准备打包发布，开始写单元测试，虽然就2，3个单元，跑完测试，突然发现， 嚓， 怎么有对象木有人引用？ 按照 dex 的规定，应该每个对象都应该被引用的啊， 不对，一定是那里出了问题，虽然没有被引用的对象很少，不过他们的出现就代表我解析肯定是有问题的。写完单元测试，开始复习 java 的字节码和 dex 结构。

第七天：没啥头绪，继续写单元测试。

第八天：突然想起来，java 是动态语言啊，难道这些对象是被字节码直接引用呃，马上反编译了下 dex 文件，果然是，那么问题来了，尼玛我需要引入一个 dex 的反编译器啊， dexerity 并不提供反编译功能。 网上找了一圈，找到另外一个神库，叫 androidguard。300 多个赞，看起来很不错哦，看了看代码，突然发现，这个库里面居然有一个纯 python 的 dex 解析器，还有一个纯 python 的反编译器。这岂不是意味着我可以一脚踢开 dexerity, 从此告别混合编程？ 虽然这个意味着我需要重新写解析器接口， 三思之下，没有能挡住诱惑。

第九天：基于 androidguard 重写了脚本，加入反编译器，未引用的对象一下子少了一半，但为什么还是有。。。

第十天：想起来原来不仅是代码里面可以引用，调试信息里面应该也可以引用，而dex文件使用的调试信息是啃爹的 drawf 格式，意味着，调试信息本身也是一种虚拟机的字节码，也需要反编译。尼玛。 再次在 androidguard 里面导入了一个调试信息反编译器，发现 androidguard 自己并没有使用这个反编译器，心开始觉得有点奇怪。果然一挂上去，反编译器 crash 了。上天，你是要我去调试一个反编译器么。。

第十一天：查半天发现原来作者解析 leb128 数据结构的时候误以为 python 和 C++ 一样，都是拿最高位来当符号位的，too young too simple，蟒蛇教哪有这么低等的设定，C++ 的屌丝们怎么可能理解我们已经到了一个不需要区分 unsigned 和signed的共产主义社会呢，还有就算是这样，负数在C++里面是用补数存的啊，你居然拿来做位操作，说好的高手呢。然后终于理解为何他们自己都不用了， 修好给原作者发了一个patch, 同时告诉ta，他们的反编译器可以用了。

数终于对了，终于对了啊， 一个字节都不带差了。。

当然这两位哥拿我的patch谢谢都没有说一句这种事情我会主动告诉你嘛。

第十二天：用了用自己的工具，觉得挺满意的，测了十几个dex文件，跑了跑单元测试， 都没有啥问题，于是，写完了。。。

于是一个预估3天的东西，最后写了12天，2个星期多一点。最后看了下统计, 增删1万行代码左右。 

不知道大家看完上面的例子，看出什么端倪没有？

一个软件的开发量非常难估准，我自认为经验还算是丰富，为何还是没有看到共享对象的问题，没有看到代码反编译的问题，也没有看到调试代码反编译的问题？

这里就有一个哲学解释，因为一般来说，软件工程师解决的问题都是未知的问题，如果是已知的问题，一般没有解决的必要，也没有价值， 这个和建筑还不一样，软件工程中的可复用性非常高，土木工程里面修完一栋高楼，要修第二栋，那么对不起，除了图纸以外其他的，其他能复用的很少， 该搬砖还得搬砖， 该挖土还得挖土。 而软件工程里面，基本上一个粘贴复制就完了，这种工作也不会有价值，于是软件工程一般是要求你修一个完全不一样的楼，或者是在已有的楼上面修一个更高的楼。

引入了第三方的库以后马上引入了复杂度，事实上所有软件开发中第三方库的引入都很难避免。除非你想把这个世界上的东西都重写一遍， 而这些复杂度，完全没法预料，只能靠经验判断。

说了这么多，其实整个开发不外乎分为三个阶段：

a . 预计使用 dexdump, 分析文本, 可以使用，可以做回归测试。  
b. 切换到 dexterity, 误差已经在 10% 以内。  
b+ , 潜在做法，同时用 dexterity 和 android guard, 保留已有代码。  
c. 切换到 android guard. 完全消除误差

国内大部分互联网思维公司都会在a 这个阶段就停下了来，反正差不多能用，老板一看，工期还差不多，KPI 也有保证，好一点的做到b ，实用主义嘛，上线比啥都重要。 

那么问题在哪里呢？

无论是 a, 还是 b, 都是把问题推到将来， 如果使用 a , 那么之后的尺寸测量讲非常不准确，软件开发的限制会越来越大，最终大家无所适从，得过且过,最后写成一个垃圾堆。

如果使用 b, 或者 b+, 问题小了很多，但是混合编程的问题在于有一部分代码是C++的。而用C++做脚本是一个很啃爹的事情。因为不但要维护脚本，还要维护它的编译环境，一旦编译环境发生变化，而写脚本的人又离职了，那基本大家只能一边哭一边去 debug Makefile 这种反人类的东西。

说到底，a, b, b+ 方案看起来是省了时间， 其实会为后续的工作带来无穷无尽的问题，大量的问题会慢慢积累起来来，然后某天，轰的一声坍塌，一句话，出来混，迟早都要还的。

只有c方案，在之后并无成本，一步一个脚印，看似移动速度比a, b, b+慢，事实上长期看来，是效率最高的做法。

Fred Brooks 在 1996 年说过 软件开发没有银弹 ( no silver bullet )， 这个理论到现在也成立。在互联网时代，用户对时间／品质的要求都是极其高的，而长期来看，品质可能比时间更重要。

这或许是为什么苹果从来不1个星期发一个版本。。

要知道，做一件事情的效率 ＝ 成果／时间，如果成果为0，那么这个事情你用了一天或者1年，效率都是0.

要么是杰作，要么是狗屎.

代码地址 https://github.com/fredrikluo/dexsize_analyze 

<div class="pvc_clear">
</div>

<p id="pvc_stats_97" class="pvc_stats " element-id="97">
  <img src="http://www.fredrik-luo.com/blog/wp-content/plugins/page-views-count/ajax-loader.gif" border=0 />
</p>

<div class="pvc_clear">
</div>